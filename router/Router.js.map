{"version":3,"sources":["../../src/router/Router.js"],"names":["Route","isFunction","qs","merge","cloneDeep","configureCache","ClientContext","EventEmitter","powerLinkHandler","fromServer","defaultClientCacheConfig","Router","process","env","MOOV_RUNTIME","runOn","client","server","fn","page","e","params","request","response","status","error","message","stack","loading","location","pathname","search","path","query","parse","method","options","initialLoad","runAll","state","callback","action","prevLocation","context","emit","run","historyState","get","handlers","routes","push","pushRoute","fallbackHandlers","appShellConfigured","handler","errorHandler","router","route","routePath","rest","spec","findMatchingRoute","match","isClientCachingEnabled","getCacheHandler","window","clientCacheConfig","find","type","protocol","replace","hostname","port","fromServerHandlers","res","result","getCachedResponse","hasOwnProperty","endsWith","format","cachedFromServerResult","isBrowser","serverHandlers","filter","h","fromClientHandler","cacheHandler","getCachedPatch","historyStatePatch","createLocation","length","toPromise","then","Promise","resolve","routeIndexHeader","headers","routeIndex","parseInt","isNaN","toUpperCase","url","URL","undefined","willFetchFromUpstream","some","history","listen","onLocationChange","bind","stringifyOptions","nextParams","stringify","ignoreQueryPrefix"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport Route from 'route-parser'\nimport isFunction from 'lodash/isFunction'\nimport qs from 'qs'\nimport merge from 'lodash/merge'\nimport cloneDeep from 'lodash/cloneDeep'\nimport { configureCache } from './serviceWorker'\nimport ClientContext from './ClientContext'\nimport EventEmitter from 'eventemitter3'\nimport powerLinkHandler from './powerLinkHandler'\nimport fromServer from './fromServer'\nimport defaultClientCacheConfig from './defaultClientCacheConfig'\n\n/**\n * Provides routing for MUR-based applications and PWAs.  This class is inspired by express and uses https://github.com/rcs/route-parser,\n * which supports sophisticated pattern matching including optional paths, params, and splatting.\n *\n * Example:\n * ```js\n *  const router = new Router()\n *\n *  router.get('/products/:id', ({ id }) => {\n *    // fetch product from upstream API (you'll need to write this function)\n *    return fetchProduct(id).then(result => {\n *      return result.product // this will be the result of router.run()\n *    })\n *  })\n *\n *  // assuming env.path = /products/1 and env.method = 'GET'\n *  router.run() // => the details for product 1\n * ```\n *\n * Routes can be divided into multiple files to increase maintainability using the \"use()\" method.  For example:\n *\n * ```js\n *  // /scripts/api/router.js\n *\n *  const appShell = require('/build/index.html.js)\n *\n *  module.exports = new Router()\n *    .fallback(() => appShell) // render the PWA's app shell for all unmatched routes\n *    .use('/products', require('/api/products.js'))\n * ```\n *\n * ```js\n *  // /scripts/api/products.js\n *\n *  module.exports = new Router()\n *    .get('/:id', ({ id }) => new Promise((resolve, reject) => {\n *      // fetch product from upstream API...\n *     }))\n * ```\n *\n * ```js\n *  // /scripts/index.js\n *\n *  const router = require('/api/router')\n *\n *  module.exports = function() {\n *    // ...\n *    router.run().then((result) => {\n *      const body = typeof result === 'string' ? result : JSON.stringify(result)\n *      sendResponse({ body, htmlparsed: true })\n *    })\n *  }\n * ```\n *\n * Router is an EventEmitting that fires the following events:\n *\n * - `before`: Fires before a route is run, passing an object containing `request` and `response`.\n * - `after`: Fires after a route is run and all handlers have finised, passing an object containing `request` and `response`.\n * - `fetch`: Fires when a `fromServer` handler runs on the client, resulting in a fetch from the server. No arguments are passed to the event handler.\n */\nexport default class Router extends EventEmitter {\n  routes = []\n  appShellConfigured = false\n  isBrowser = process.env.MOOV_RUNTIME === 'client'\n  clientCacheConfig = defaultClientCacheConfig\n\n  fallbackHandlers = [\n    {\n      runOn: { client: true, server: true },\n      fn: () => ({ page: '404' })\n    }\n  ]\n\n  constructor() {\n    super()\n    this.get('/.powerlinks.js', fromServer(powerLinkHandler))\n  }\n\n  errorHandler = (e, params, request, response) => {\n    if (response && response.status) {\n      response.status(500, 'error')\n    }\n    return { page: 'Error', error: e.message, stack: e.stack, loading: false }\n  }\n\n  pushRoute(method, path, handlers) {\n    // We are explicitly setting JSON and AMP routes in order to handle\n    // model data routes\n    this.routes.push({ path: new Route(path + '.json'), method, handlers })\n    this.routes.push({ path: new Route(path + '.amp'), method, handlers })\n    this.routes.push({ path: new Route(path), method, handlers })\n    return this\n  }\n\n  /**\n   * Registers a GET route\n   * @param {String} path A path pattern\n   * @param {...any} handlers Handlers that return patches to be merged into the app state\n   * @return {Router} this\n   */\n  get(path, ...handlers) {\n    return this.pushRoute('GET', path, handlers)\n  }\n\n  /**\n   * Registers a POST route\n   * @param {String} path A path pattern\n   * @param {...any} handlers Handlers that return patches to be merged into the app state\n   * @return {Router} this\n   */\n  post(path, ...handlers) {\n    return this.pushRoute('POST', path, handlers)\n  }\n\n  /**\n   * Registers a PATCH route\n   * @param {String} path A path pattern\n   * @param {...any} handlers Handlers that return patches to be merged into the app state\n   * @return {Router} this\n   */\n  patch(path, ...handlers) {\n    return this.pushRoute('PATCH', path, handlers)\n  }\n\n  /**\n   * Registers a PUT route\n   * @param {String} path A path pattern\n   * @param {...any} handlers Handlers that return patches to be merged into the app state\n   * @return {Router} this\n   */\n  put(path, ...handlers) {\n    return this.pushRoute('PUT', path, handlers)\n  }\n\n  /**\n   * Registers a DELETE route\n   * @param {String} path A path pattern\n   * @param {...any} handlers Handlers that return patches to be merged into the app state\n   * @return {Router} this\n   */\n  delete(path, ...handlers) {\n    return this.pushRoute('DELETE', path, handlers)\n  }\n\n  /**\n   * Registers an OPTIONS route\n   * @param {String} path A path pattern\n   * @param {...any} handlers Handlers that return patches to be merged into the app state\n   * @return {Router} this\n   */\n  options(path, ...handlers) {\n    return this.pushRoute('OPTIONS', path, handlers)\n  }\n\n  /**\n   * Designates the handlers for unmatched routes\n   * @param {Function} callback A function that returns a promise that resolves to the content to return\n   * @return {Router} this\n   */\n  fallback(...handlers) {\n    this.fallbackHandlers = handlers\n    return this\n  }\n\n  /**\n   * Defines the handler for the app-shell.  Generally this should be a single fromServer handler that return\n   * the global data for menus and navigation and sets loading: true.  The app-shell is used in offline mode\n   * during initial landing on an uncached SSR result.\n   * @param {...any} handlers Handlers that return patches to be merged into the app state\n   * @return {Router} this\n   */\n  appShell(...handlers) {\n    this.appShellConfigured = true\n    return this.get('/.app-shell', ...handlers)\n  }\n\n  /**\n   * Returns `true` if `appShell` has been called to configure an appShell route, otherwise `false`.\n   * @return {Boolean}\n   */\n  isAppShellConfigured() {\n    return this.appShellConfigured\n  }\n\n  /**\n   * Sets the handler for errors thrown during route handling\n   * @param {Function} handler A function that returns a promise that resolves to the content to return\n   * @return {Router} this\n   */\n  error(handler) {\n    this.errorHandler = handler\n    return this\n  }\n\n  /**\n   * Registers a set of nested routes.\n   *\n   * Example:\n   *\n   *  Router root = new Router()\n   *\n   *  Router products = new Router()\n   *  products.get('/:id', ({ id }) => {\n   *    return Promise.resolve(id)\n   *  })\n   *\n   *  root.use('/products', products)\n   *\n   *  // url: /products/1\n   *  root.run().then(result => console.log(result)) // => 1\n   *\n   * @param {String} path The parent path\n   * @param {Router} router A router to handle the nested routes\n   * @return {Router} this\n   */\n  use(path, router) {\n    for (let route of router.routes) {\n      const { path: routePath, ...rest } = route\n      this.routes.push({ path: new Route(path + routePath.spec), ...rest })\n    }\n    return this\n  }\n\n  /**\n   * Returns `true` if the request will be cached on the client, otherwise `false`.\n   * @param {Object} request\n   * @return {Boolean}\n   */\n  willCacheOnClient(request) {\n    const { match } = this.findMatchingRoute(request)\n    return this.isClientCachingEnabled(match)\n  }\n\n  /**\n   * Returns `true` if the route has a cache handler with `client: true`, otherwise `false`.\n   * @private\n   * @param {Route} route\n   * @return {Boolean}\n   */\n  isClientCachingEnabled(route) {\n    const handler = this.getCacheHandler(route)\n\n    if (handler && handler.client) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Configures service worker runtime caching options\n   * @param {Object} options\n   * @param {Object} options.cacheName The name of the runtime cache\n   * @param {Object} options.maxEntries The max number of entries to store in the cache\n   * @param {Object} options.maxAgeSeconds The TTL in seconds for entries\n   * @return {Router} this\n   */\n  configureClientCache(options) {\n    if (typeof window !== 'undefined') {\n      this.clientCacheConfig = { ...defaultClientCacheConfig, ...options }\n      configureCache(this.clientCacheConfig)\n    }\n    return this\n  }\n\n  /**\n   * Finds the cache handler for the specified request\n   * @param {Object} route\n   * @return {Object} The handler\n   */\n  getCacheHandler(route) {\n    const handlers = route ? route.handlers : this.fallbackHandlers\n    return handlers && handlers.find(handler => handler.type === 'cache')\n  }\n\n  /**\n   * Creates an object describing the browser location\n   * @return {Object}\n   */\n  createLocation() {\n    return {\n      protocol: location.protocol.replace(/:/, ''),\n      pathname: location.pathname,\n      search: location.search,\n      hostname: location.hostname,\n      port: location.port\n    }\n  }\n\n  /**\n   * Returns a merged cached response for all specified fromServer handler.  Will return null\n   * if we're missing a cached response for any of the handlers\n   * @param {Object[]} fromServerHandlers\n   * @param {ClientContext} res\n   * @return {Object}\n   */\n  async getCachedPatch(fromServerHandlers, res) {\n    const result = {}\n\n    for (let handler of fromServerHandlers) {\n      const response = await handler.getCachedResponse(res)\n\n      if (response) {\n        merge(result, response)\n      } else {\n        return null\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Runs the current url (from env) and generates a result from each the matching route's handlers.\n   * @param {Object} request The request being served\n   * @param {String} request.path The url path\n   * @param {String} request.method The http method\n   * @param {Response} response The response object\n   * @param {Object} options\n   * @param {Boolean} [options.initialLoad=false] Set to true if this is the initial load of the application.  This will cause the HTML to be cached for the current path\n   * @return {Object} Generates state objects\n   */\n  async *run(request, response, { initialLoad = false, historyState = {} } = {}) {\n    const { match, params } = this.findMatchingRoute(request)\n\n    try {\n      request.params = params\n\n      if (!request.params.hasOwnProperty('format')) {\n        if (request.path.endsWith('.json')) {\n          request.params.format = 'json'\n        } else if (request.path.endsWith('.amp')) {\n          request.params.format = 'amp'\n        }\n      }\n\n      const handlers = match ? match.handlers : this.fallbackHandlers\n\n      let cachedFromServerResult = null\n\n      if (this.isBrowser && !initialLoad) {\n        const serverHandlers = handlers.filter(h => h.type === 'fromServer')\n        const fromClientHandler = handlers.find(h => h.type === 'fromClient')\n        const cacheHandler = handlers.find(h => h.type === 'cache')\n\n        // run the cache handler so the caching headers are set on the request for the service worker\n        if (cacheHandler && cacheHandler.client) {\n          cacheHandler.fn(params, request, response)\n          cachedFromServerResult = await this.getCachedPatch(serverHandlers, response)\n        }\n\n        const historyStatePatch = {\n          location: this.createLocation(),\n          ...historyState,\n          loading: serverHandlers.length > 0 && cachedFromServerResult == null\n        }\n\n        if (cachedFromServerResult && fromClientHandler) {\n          // If we have a cached result from the server, merge the historyStatePatch into it so we only have to yield once\n          // in the fromClient handler\n          cachedFromServerResult = merge({}, historyStatePatch, cachedFromServerResult)\n        } else {\n          // Here we ensure that the loading mask is displayed immediately if we are going to fetch from the server\n          // and that the app state's location information is updated.\n          yield merge({}, historyStatePatch, cachedFromServerResult)\n        }\n      }\n\n      for (let handler of handlers) {\n        if (typeof handler === 'function') {\n          handler = {\n            runOn: { server: true, client: true },\n            fn: handler\n          }\n        }\n\n        // we've already run the cache handler on the client above\n        if (handler.type === 'cache' && this.isBrowser) {\n          continue\n        }\n\n        // skip server handlers when running in the browser\n        if (!handler.runOn.client && this.isBrowser) {\n          continue\n        }\n\n        // skip client handlers when running on server\n        if (!handler.runOn.server && !this.isBrowser) {\n          continue\n        }\n\n        // skip client handlers when serving an AJAX request on the server\n        if (request.path.endsWith('.json') && (handler.runOn.server !== true || this.isBrowser)) {\n          continue\n        }\n\n        if (handler.type === 'fromServer') {\n          if (cachedFromServerResult != null) {\n            // if we already have a cached response, we don't need to run the fromServer handler\n            // again.\n            continue\n          } else {\n            this.emit('fetch')\n          }\n        }\n\n        const result = await this.toPromise(handler.fn, params, request, response)\n\n        if (handler.type === 'fromClient' && this.isBrowser) {\n          // If this is the fromClient handler, yield it's result along with any cached fromServer\n          // results at the same time. Doing these all at once reduces cached page transitions to to\n          // a single react render cycle.\n          yield merge({}, result || {}, cachedFromServerResult)\n        } else if (result) {\n          yield result\n        }\n      }\n    } catch (err) {\n      // We emit an error event here so that we can pass the error to the error reporter\n      // while still allowing the user to provide their own error handler function.\n      this.emit('error', err)\n\n      // call the .error() function registered by the user\n      yield this.errorHandler(err, params, request, response)\n    }\n  }\n\n  /**\n   * Runs all client and server handlers for the specified path and method\n   * @param {Object} request The request being served\n   * @param {String} request.path The url path\n   * @param {String} request.method The http method\n   * @param {Response} response The response object\n   * @param {Object} options\n   * @param {Object} [state={}] The accumulated state from other handlers\n   * @return {Object} The merged result of all handlers\n   */\n  async runAll(request, response, options, state = {}) {\n    state = cloneDeep(state) // prevent initial state from being mutated\n\n    for await (let result of this.run(request, response, options)) {\n      if (typeof result === 'string') {\n        state = result\n      } else {\n        merge(state, result)\n      }\n    }\n\n    return state\n  }\n\n  /**\n   * Converts specified callback to a promise\n   * @param {Function/Object} callback A function that returns a Promise that\n   *  resolves to the new state, a function that returns the new state, or the new state itself.\n   * @param {Object} params The request parameters\n   * @param {Object} request The request object with body and headers\n   * @param {Response} response The response object\n   */\n  toPromise(callback, params, request, response) {\n    if (isFunction(callback)) {\n      const result = callback(params, request, response)\n\n      if (result && result.then) {\n        // callback returned a promise\n        return result\n      } else {\n        // callback returned the new state\n        return Promise.resolve(result)\n      }\n    } else {\n      // callback is the new state\n      return Promise.resolve(callback)\n    }\n  }\n\n  /**\n   * Returns the matching route and parsed params for the specified path and method\n   * @param {Object} request The http request\n   * @return {Object} an object with match and params\n   */\n  findMatchingRoute(request) {\n    let params\n    let { path, query, method = 'GET' } = request\n\n    const routeIndexHeader = request.headers && request.headers.get('x-xdn-route')\n\n    if (routeIndexHeader != null) {\n      // route passed in from the edge\n      const routeIndex = parseInt(routeIndexHeader)\n\n      if (!isNaN(routeIndex)) {\n        const route = this.routes[routeIndex]\n        const params = route ? route.path.match(path) : {}\n        return { match: route, params: { ...params, ...query } }\n      }\n    }\n\n    // fall back to matching the route\n    method = method.toUpperCase()\n\n    const match = this.routes\n      .filter(route => method === route.method)\n      .find(route => (params = route.path.match(path)))\n\n    return { match, params: { ...params, ...query } }\n  }\n\n  /**\n   * Returns true if the URL points to a route that has a proxyUpstream handler.\n   * @param {String} url The url to check\n   * @param {String} [method='get']\n   * @return {Boolean}\n   */\n  willNavigateToUpstream(url, method = 'get') {\n    const { pathname: path, search } = new URL(\n      url,\n      typeof window !== 'undefined' ? window.location : undefined\n    )\n    return this.willFetchFromUpstream({ path, search, method })\n  }\n\n  /**\n   * Returns true if the route will result in the server connecting to the\n   * upstream site due to the presence of a `proxyUpstream` handler or `fromOrigin` handler, otherwise\n   * false.\n   * @private\n   * @param {Object} request\n   * @return {Boolean}\n   */\n  willFetchFromUpstream(request) {\n    const { match } = this.findMatchingRoute(request)\n    let handlers = match ? match.handlers : this.fallbackHandlers\n    return handlers.some(\n      handler => handler.type === 'proxyUpstream' || handler.type === 'fromOrigin'\n    )\n  }\n\n  /**\n   * Runs all client and server handlers for the specified location and returns state\n   */\n  fetchFreshState = location => {\n    const { pathname, search } = location\n    const request = { path: pathname, search, query: qs.parse(search), method: 'GET' }\n    const response = new ClientContext()\n    const options = { initialLoad: false }\n    return this.runAll(request, response, options, location.state)\n  }\n\n  /**\n   * Called when the location is changed on the client\n   * @param {Function} callback A callback to pass the new state to\n   * @param {Object} location The new location\n   */\n  onLocationChange = async (callback, location, action) => {\n    // no need to run the route if the location hasn't changed\n    if (\n      this.prevLocation &&\n      location.pathname === this.prevLocation.pathname &&\n      location.search === this.prevLocation.search\n    ) {\n      return\n    }\n\n    this.prevLocation = location // this needs to come before handlers are called or going back while async handlers are running will lead to a broken state\n\n    if (action === 'REPLACE') return\n\n    const { pathname, search } = location\n    const request = { path: pathname, search, query: qs.parse(search), method: 'GET' }\n    const context = new ClientContext()\n    const { state } = location\n\n    this.emit('before', { request, response: context, action })\n\n    if (action === 'PUSH' || !state) {\n      /*\n       * Why limit action to PUSH here? POP indicates that the user is going back or forward\n       * In those cases, if we have location.state, we can assume it's the full state.  We don't need to\n       * do anything for replace.\n       */\n      for await (let state of this.run(request, context, { historyState: state })) {\n        callback(state, action)\n      }\n    } else if (state) {\n      callback(state, action) // called when restoring history state and applying state from Link components\n    }\n\n    this.emit('after', { request, response: context })\n  }\n\n  /**\n   * Calls the specified callback whenever the current URL changes\n   * @param {History} history\n   * @param {Function} callback\n   * @return {Router} this\n   */\n  watch(history, callback) {\n    this.history = history\n    this.prevLocation = history.location\n\n    history.listen(this.onLocationChange.bind(this, callback))\n\n    const { pathname, search } = history.location\n    const request = { path: pathname, search, query: qs.parse(search), method: 'GET' }\n    const context = new ClientContext(request)\n\n    this.emit('after', { request, response: context, initialLoad: true })\n\n    return this\n  }\n\n  /**\n   * Provides an easy way to navigate by changing some but not all of the query params.  Any keys\n   * included in the params object are applied as new query param values.  All other query params are preserved.\n   * @param {Object} params Key/value pairs to apply to the query string.  Specifying a value of undefined or null will remove that parameter from the query string\n   * @param {Object} [stringifyOptions={}] Options of stringifying all query params.  Applied for `qs.stringify`: https://github.com/ljharb/qs#stringifying\n   */\n  applySearch(params, stringifyOptions = {}) {\n    const { history } = this\n\n    const nextParams = qs.stringify(\n      {\n        ...qs.parse(history.location.search, { ignoreQueryPrefix: true }),\n        ...params\n      },\n      stringifyOptions\n    )\n\n    history.replace(`${history.location.pathname}?${nextParams}`)\n  }\n}\n"],"file":"Router.js"}