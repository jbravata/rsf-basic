{"version":3,"sources":["../../src/router/fromServer.js"],"names":["fetchLatest","StaleResponseError","abortPrefetches","resumePrefetches","isServiceWorkerReady","HANDLER","RESPONSE_TYPE","SURROGATE_KEY","REACT_STOREFRONT","API_VERSION","CLIENT_IF","getAPIVersion","doFetch","fetch","url","cache","onlyHit","originalResponse","require","location","href","headers","credentials","then","response","redirected","redirectTo","status","json","result","loading","is","parsed","URL","history","window","moov","hostname","push","pathname","search","assign","Error","fromServer","handlerPath","getURL","createURL","type","runOn","server","client","getCachedResponse","clientCache","fn","params","request","set","path","endsWith","get"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Â© 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport { fetchLatest, StaleResponseError } from '../fetchLatest'\nimport { abortPrefetches, resumePrefetches, isServiceWorkerReady } from './serviceWorker'\nimport {\n  HANDLER,\n  RESPONSE_TYPE,\n  SURROGATE_KEY,\n  REACT_STOREFRONT,\n  API_VERSION,\n  CLIENT_IF\n} from './headers'\nimport getAPIVersion from './getAPIVersion'\n\nlet doFetch\n\n/**\n * Fetch's state as json from the specified url\n * @private\n * @param {String} url The url to fetch\n * @param {Object} options\n * @param {String} options.cache Set to \"force-cache\" to cache the response in the service worker.  Omit to skip the service worker cache.\n * @param {Object} originalResponse Response object/context which can be modified on the client\n * @return {Object} A state patch\n */\nexport async function fetch(url, { cache = 'default', onlyHit = false } = {}, originalResponse) {\n  abortPrefetches()\n  doFetch = doFetch || fetchLatest(require('isomorphic-unfetch'))\n\n  const { href } = location\n\n  const headers = {\n    [REACT_STOREFRONT]: 'true', // allows back end handlers to quickly identify PWA API requests,\n    [API_VERSION]: getAPIVersion() // needed for the service worker to determine the correct runtime cache name and ensure that we're not getting a cached response from a previous api version\n  }\n\n  if (onlyHit) {\n    headers[CLIENT_IF] = 'cache-hit'\n  }\n\n  try {\n    const result = await doFetch(url, {\n      cache: cache || 'default',\n      credentials: 'include',\n      headers\n    }).then(response => {\n      const { redirected, url } = response\n\n      if (redirected) {\n        redirectTo(url)\n        // This allows downstream event handlers to know if a response was redirected\n        if (originalResponse) {\n          originalResponse.redirected = true\n        }\n      } else {\n        resumePrefetches()\n\n        if (response.status === 204) {\n          return null\n        } else {\n          return response.json()\n        }\n      }\n    })\n\n    if (result != null && location.href === href) {\n      // Make sure the user hasn't changed the page since the request was sent.\n      // If they have the response is stale and shouldn't be used.\n      // We can get here when switching back to a page that is cached in the DOM by Pages\n      return { loading: false, ...result }\n    }\n  } catch (e) {\n    if (StaleResponseError.is(e)) {\n      return null\n    } else {\n      throw e\n    }\n  }\n}\n\n/**\n * Handles a redirect response.  Will do a client side navigation if the URL has the same hostname as the app, otherwise will\n * reload the page.\n * @private\n * @param {String} url\n */\nfunction redirectTo(url) {\n  if (url) {\n    const parsed = new URL(url)\n    const { history } = window.moov\n\n    if (parsed.hostname === window.location.hostname) {\n      history.push(parsed.pathname + parsed.search)\n    } else {\n      window.location.assign(url)\n    }\n  } else {\n    throw new Error('Received a redirect without a location header.')\n  }\n}\n\n/**\n * Creates a handler that fetches data from the server.\n *\n * The `handlerPath` should point to a module that exports a function that takes params, request, and response,\n * and returns an object that should be applied to the app state.  For example:\n *\n * ```js\n * // routes.js\n * router.get('/p/:id'\n *   fromServer('./product/product-handler')\n * )\n *\n * // product/product-handler.js\n * export default function productHandler(params, request, response) {\n *   return fetchFromUpstreamApi(`/products/${params.id}`)\n *     .then(res => res.json())\n *     .then(productData => ({ // the shape of this object should match your AppModel\n *       page: 'Product',\n *       product: productData\n *     }))\n * }\n * ```\n *\n * When the request path ends in \".json\", the json response will be returned verbatim.  In all other cases, server-side rendered HTML\n * will be returned.\n *\n * You can also send a verbatim string response using `response.send(body)`.  For example:\n *\n * ```js\n * // routes.js\n * router.get('/my-api'\n *   fromServer('./my-api-handler')\n * )\n *\n * // my-api-handler.js\n * export default function myApiHandler(params, request, response) {\n *   response\n *     .set('content-type', response.JSON)\n *     .send(JSON.stringify({ foo: 'bar' }))\n * }\n * ```\n *\n * When `response.send()` is called in a handler, react-storefront will never perform server-side rendering.\n *\n * @param {String} handlerPath The path to the module that exports a handler function that returns\n *  state to apply to the app state tree.  The shape of the returned object should match your `AppModel`.\n * @param {Function} getURL An optional function that returns the back end url to call when fetching.  You only need\n *  to specify this if you want to override the default URL.\n * @return {Function}\n */\nexport default function fromServer(handlerPath, getURL) {\n  if (handlerPath == null) {\n    throw new Error(\n      'You must provide a path to a handler in fromServer().  Please check your routes.'\n    )\n  }\n\n  /**\n   * Creates the URL for fetching json from the server, using `getURL` if provided,\n   * allowing the user to override the URL convention.\n   * @private\n   */\n  function createURL() {\n    const url = `${location.pathname}.json${location.search}`\n    return getURL ? getURL(url) : url\n  }\n\n  return {\n    type: 'fromServer',\n    runOn: {\n      server: true,\n      client: true // fromServer handlers run on the client too - we make an ajax request to get the state from the server\n    },\n    async getCachedResponse(response) {\n      if (!isServiceWorkerReady()) return null\n      return await fetch(createURL(), { cache: response.clientCache, onlyHit: true })\n    },\n    async fn(params, request, response) {\n      if (typeof handlerPath === 'string') {\n        // handler path has not been transpiled, fetch the data from the server and return the result.\n        return fetch(createURL(), { cache: response.clientCache }, response)\n      } else {\n        // indicate handler path and asset class in a response header so we can track it in logs\n        response.set(HANDLER, handlerPath.path)\n        response.set(RESPONSE_TYPE, request.path.endsWith('.json') ? 'json' : 'ssr')\n\n        // use the handler path as the surrogate cache key if one has not already been set by cache#surrogateKey\n        if (!response.get(SURROGATE_KEY)) {\n          response.set(SURROGATE_KEY, handlerPath.path)\n        }\n\n        // handler path has been transpiled to a function\n        return handlerPath(params, request, response)\n      }\n    }\n  }\n}\n"],"file":"fromServer.js"}